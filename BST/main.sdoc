<?xml version='1.0' encoding='iso-2022-jp'?>
<doc xml:lang="ja" encoding="iso-2022-jp">
<head>
<title>情報通信工学実験A(情報系実験)テキスト</title>
<author>担当: 国島丈生、山内仁</author>
<date>2001-11-21</date>
</head>
<body>
<section title="2分探索木">
計算機で大量のデータを扱う場合、単なる配列や連結リストでは検索・挿入・
削除などの操作がひじょうに遅くなる。たとえば配列で10,000件のデータを持っ
ているときに、その先頭に1つ要素を挿入しようとすると、10,000件のデータ
をすべて1つずつ後ろへずらさなければならない<note>アルゴリズムの計算量
がO(n) (データ数nに比例する)であるという。これは、検索ではかなり時間が
かかる部類に入る。</note>。そこで、より効率の良いデータ操作が行えるデー
タ構造がいろいろ考えられている。

この実験では、それらの中で比較的簡単な<dfn>2分探索木</dfn> (Binary
Search Tree) を取り上げる。これは2分木の特殊な場合であり、前回の実装を
使って実現することができる。
<subsection title="定義">
2分探索木は、次の規則に基づいて各節点に集合の要素を1つずつ対応づけた2 
分木である<note>ここでは「小さい」「大きい」という言葉を用いて直感的に
説明しているが、厳密には全順序(total order)であればよい。整数や実数の
大小関係、文字列の辞書順などは全順序の例である。</note>。
<ul>
<li>任意の節点xに対し、xの左部分木に格納された要素はすべてxより小さい。</li>
<li>任意の節点xに対し、xの右部分木に格納された要素はすべてxより大きい。</li>
</ul>

<a href="#BST"></a>に2分探索木の例を示す。
<figure title="2分探索木の例" id="BST" src="bintree.eps,bintree.gif" style="width:8cm">
</figure>
</subsection>
<subsection title="2分探索木の基本操作">
2分探索木に対する基本操作は次のようなものが考えられる。
<ul>
<li>MEMBER(x, A): 要素xが2分探索木Aに含まれているかどうかを調べる。</li>
<li>INSERT(x, A): 要素xを2分探索木A(の適切なところ)に挿入する。結果は2
分探索木になっていなければならない。</li>
<li>MIN(A): 2分探索木Aのうち、最小の要素に対応づけられている節を得る。</li>
<li>DELETE(x, A): 要素xを2分探索木から削除する。結果は2分探索木になっ
ていなければならない。</li>
</ul>
</subsection>

これらの操作はいずれも再帰的手続きによって記述することができる。たとえ
ば MEMBER(x, A)は次のようになる。
<program title="MEMBER(x,A)">
<![CDATA[
boolean MEMBER(x, A) {
  if (A == nil) {
    return false;  /* 2分探索木は空 */
  } else if (x == A.iData) {
    return true;  /* A の根と x が対応 */
  } else if (x < A.iData) {
    return MEMBER(x, A.leftTree);  /* x があるなら左部分木にあるはず */
  } else { /* x > A.iData */
    return MEMBER(x, A.rightTree); /* x があるなら右部分木にあるはず */
  }
}
]]>
</program>

INSERT(x, A), DELETE(x, A)は、結果がまた2分探索木になっていなければな
らないため、実装が複雑になる。例としてDELETE(x,A)の実装方針を示す。
<ol>
<li>Aが空であれば何もしない。</li>
<li>Aが空でない場合
<ol>
<li>x &lt; (Aの根).iData であれば、Aの左部分木からxを消去し、結果得ら
れた2分探索木をAの左部分木とする。</li>
<li>x &gt; (Aの根).iData であれば、Aの右部分木からxを消去し、結果得ら
れた2分探索木をAの右部分木とする。</li>
<li>x == (Aの根).iData であった場合、Aの根を削除することになる。
<ol>
<li>もしA には左部分木しかなければ、Aの根を削除して得られる木はAの左部
分木そのものになる。右部分木しかない場合も同様である。</li>
<li>Aに左部分木も右部分木もある場合は、右部分木中の最小の要素を求める。
これをyとしておくと、xを削除したあとの2分探索木は、根がy、左部分木が
A.leftTree、右部分木がDELETE(y, A.rightTree)<note>右部分木から、その中
の最小の要素であるyを削除して得られる2分探索木。</note>になる。</li>
</ol>
</li>
</ol>
</li>
</ol>
</section>
</body>
</doc>